<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="javascripts/jqueryui/css/ui-lightness/jquery-ui-1.8.21.custom.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet_iframe.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">

    <script type="text/javascript" src="javascripts/jqueryui/js/jquery-1.7.2.min.js"></script>
    <script type="text/javascript" src="javascripts/jqueryui/js/jquery-ui-1.8.21.custom.min.js"></script>
    <script src="./javascripts/npg/npgmain.js"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [['$','$'], ['\\(','\\)']],
          processClass: "mathJax"
        }
      });
    </script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    <script src="./javascripts/smo.js"></script>
    <!--<script src="./javascripts/pegasos.js"></script>-->
    <script type="text/javascript">

      var default_value = 10; //number of data points
      var N = default_value;
      var data = new Array(N);
      var labels= new Array(N);
      var wb; // weights and offset structure
      var ss= 50.0; // scaling factor for drawing
      var svm= new smo.SVM();
      var trainstats;
      var dirty= true;
      var kernelid= 1;
      var rbfKernelSigma = 0.5;
      var svmC = 1.0;
      var cleared = false;

      function myinit(){

        //random initialisation
        for(var i=0; i<N; i++) {
          data[i] = [randf(-4,4), randf(-4,4)];
          labels[i] = i % 2 === 0 ? 1 : -1;
        }
        retrainSVM();
      }

      function retrainSVM() {

        if(kernelid === 1) {
          trainstats= svm.train(data, labels, { kernel: 'rbf', rbfsigma: rbfKernelSigma, C: svmC});
        }
        if(kernelid === 0) {
          trainstats= svm.train(data, labels, { kernel: 'linear' , C: svmC});
          wb= svm.getWeights();
        }

        dirty= true; // to redraw screen
      }

      function update(){
      }

      function draw(){
        if(!dirty) return;

        ctx.clearRect(0,0,WIDTH,HEIGHT);

        // draw decisions in the grid
        var density= 4.0;
        for (var x=0.0; x<=WIDTH; x+= density) {
          for (var y=0.0; y<=HEIGHT; y+= density) {
            var dec = svm.marginOne([(x-WIDTH/2)/ss, (y-HEIGHT/2)/ss]);
            if(N===1) dec = labels[0];
            // black region
            if (dec>0) ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            // white region
            else ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(x-density/2-1, y-density-1, density+2, density+2);
          }
        }

        // draw axes
        ctx.beginPath();
        // white
        ctx.strokeStyle = 'rgb(255,255,255)';
        ctx.lineWidth = 0.5;
        ctx.moveTo(0, HEIGHT/2);
        ctx.lineTo(WIDTH, HEIGHT/2);
        ctx.moveTo(WIDTH/2, 0);
        ctx.lineTo(WIDTH/2, HEIGHT);
        ctx.stroke();

        ctx.strokeStyle = 'rgb(245, 245, 245)';
        // draw datapoints. Draw support vectors larger
        for (var i=0;i<N;i++) {

          // black dots
          if (labels[i]==1) ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
          // white dots
          else ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';

          if (svm.alpha[i]>1e-2) ctx.lineWidth = 3; // distinguish support vectors
          else ctx.lineWidth = 1;

          drawCircle(data[i][0]*ss+WIDTH/2, data[i][1]*ss+HEIGHT/2, Math.floor(3+ ((svm.alpha.length == 0) ? 0 : svm.alpha[i]) *5.0/svmC));
        }

        // if linear kernel, draw decision boundary and margin lines
        if (kernelid == 0) {
          var xs= [-5, 5];
          var ys= [0, 0];
          ys[0]= (-wb.b - wb.w[0]*xs[0])/wb.w[1];
          ys[1]= (-wb.b - wb.w[0]*xs[1])/wb.w[1];
          ctx.fillStyle = 'rgb(0,0,0)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          // wx+b=0 line
          ctx.moveTo(xs[0]*ss+WIDTH/2, ys[0]*ss+HEIGHT/2);
          ctx.lineTo(xs[1]*ss+WIDTH/2, ys[1]*ss+HEIGHT/2);
          // wx+b=1 line
          ctx.moveTo(xs[0]*ss+WIDTH/2, (ys[0]-1.0/wb.w[1])*ss+HEIGHT/2);
          ctx.lineTo(xs[1]*ss+WIDTH/2, (ys[1]-1.0/wb.w[1])*ss+HEIGHT/2);
          // wx+b=-1 line
          ctx.moveTo(xs[0]*ss+WIDTH/2, (ys[0]+1.0/wb.w[1])*ss+HEIGHT/2);
          ctx.lineTo(xs[1]*ss+WIDTH/2, (ys[1]+1.0/wb.w[1])*ss+HEIGHT/2);
          ctx.stroke();

          // draw margin lines for support vectors. The sum of the lengths of these
          // lines, scaled by C is essentially the total hinge loss.
          for (var i=0;i<N;i++) {
            if (svm.alpha[i]<1e-2) continue;
            if (labels[i]==1) {
              ys[0]= (1 -wb.b - wb.w[0]*xs[0])/wb.w[1];
              ys[1]= (1 -wb.b - wb.w[0]*xs[1])/wb.w[1];
            } else {
              ys[0]= (-1 -wb.b - wb.w[0]*xs[0])/wb.w[1];
              ys[1]= (-1 -wb.b - wb.w[0]*xs[1])/wb.w[1];
            }
            var u= (data[i][0]-xs[0])*(xs[1]-xs[0])+(data[i][1]-ys[0])*(ys[1]-ys[0]);
            u = u/((xs[0]-xs[1])*(xs[0]-xs[1])+(ys[0]-ys[1])*(ys[0]-ys[1]));
            var xi= xs[0]+u*(xs[1]-xs[0]);
            var yi= ys[0]+u*(ys[1]-ys[0]);
            ctx.moveTo(data[i][0]*ss+WIDTH/2, data[i][1]*ss+HEIGHT/2);
            ctx.lineTo(xi*ss+WIDTH/2, yi*ss+HEIGHT/2);
          }
          ctx.stroke();
        }

        ctx.font="12px Verdana";
        ctx.fillStyle= 'rgb(245,245,245)';
        ctx.fillText("Converged in " + trainstats.iters + " iterations.", default_value, HEIGHT-30);
        var numsupp=0;
        for (var i=0;i<N;i++) { if(svm.alpha[i] > 1e-5) numsupp++; }
        ctx.fillText("Number of support vectors: " + numsupp + " / " + N, default_value, HEIGHT-50);

        if(kernelid === 1) ctx.fillText("Using Rbf kernel with sigma = " + rbfKernelSigma.toPrecision(2), default_value, HEIGHT - 70);
        if(kernelid === 0) ctx.fillText("Using Linear kernel", default_value, HEIGHT - 70);

        ctx.fillText("C = " + svmC.toPrecision(2), default_value, HEIGHT - 90);
        dirty = false;
      }

      function mouseClick(x, y, shiftPressed){
        // add datapoint at location of click
        data[N] = [(x-WIDTH/2)/ss, (y-HEIGHT/2)/ss];
        labels[N] = shiftPressed ? 1 : -1;
        N += 1;
        // retrain the svm
        retrainSVM();
      }

      function keyUp(key){
        if(key==82) { // 'r'
          // reset to original data and retrain
          data= data.splice(0, default_value);
          labels= labels.splice(0, default_value);
          N= 10;
          retrainSVM();
        }
        if(key==75) { // 'k'
          // toggle between kernels: rbf or linear
          kernelid= 1-kernelid; // toggle 1 and 0
          retrainSVM();
        }
      }

      function reset(){
        // reset to original data and retrain
        if(cleared){
          N = default_value;
          myinit();
          cleared = false;
          return;
        }
        data = data.splice(0, default_value);
        labels = labels.splice(0, default_value);
        N = 10;
        retrainSVM();
      }

      function clearCanvas(){
        // clear all the points and let the users do their own initialization
        data = [];
        labels = [];
        N = 0;
        ctx.clearRect(0,0,WIDTH,HEIGHT);
        /*var density= 4.0;
        for (var x=0.0; x<=WIDTH; x+= density) {
          for (var y=0.0; y<=HEIGHT; y+= density) {
            ctx.fillStyle = 'rgb(150,250,150)';
            ctx.fillRect(x-density/2-1, y-density-1, density+2, density+2);
          }
        }*/
        dirty= false;
        cleared = true;
        //return;
      }

      function keyDown(key){
      }


      // UI stuff
      function refreshC(event, ui) {
        var logC = ui.value;
        svmC= Math.pow(10, logC);
        $("#creport").text("C = " + svmC.toPrecision(2));
        retrainSVM();
      }

      function refreshSig(event, ui) {
        var logSig = ui.value;
        rbfKernelSigma= Math.pow(10, logSig);
        $("#sigreport").text("RBF Kernel sigma = " + rbfKernelSigma.toPrecision(2));
        if (kernelid==1) {
          retrainSVM();
        }
      }

      $(function() {
          // for C parameter
          $("#slider1").slider({
            orientation: "horizontal",
            slide: refreshC,
            max: 2.0,
            min: -2.0,
            step: 0.1,
            value: 0.0
          });

          // for rbf kernel sigma
          $("#slider2").slider({
            orientation: "horizontal",
            slide: refreshSig,
            max: 2.0,
            min: -2.0,
            step: 0.1,
            value: 0.0
          });
      });
    </script>

    <title>Support Vector Machine</title>
  </head>

  <body onLoad="NPGinit(10);">

    <div class="container">
      <section id="main_content">
        <h3><a class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Support Vector Machine Using the SMO Algorithm</h3>

        <p>Instructions:</p>

        <p>
        <b>mouse click</b>: add red data point<br />
        <b>shift + mouse click</b>: add green data point<br />
        <b>'k'</b>: toggle between Linear and Kernels<br />
        <b>'r'</b>: reset<br />
        </p>

        <div class="operations">
          <button class="btn" onclick="reset();">Reset</button>
          <button class="btn" onclick="clearCanvas();">Clear</button>
        </div>
        <canvas id="NPGcanvas" width="500" height="500"></canvas>
        <div id="optsdiv" style="margin: 10 auto;">
          <div style="width:180px; float: left; margin-left: 10px;">
            <div id="slider1"></div>
            <br/><span id="creport">C = 1.0</span>
          </div>
          <div style="width:180px; float: right; margin-right: 10px;">
            <div id="slider2"></div>
            <br/><span id="sigreport">RBF Kernel sigma = 1.0</span>
          </div>
        </div>

        <!--<p><small>Please get a real browser if the 'canvas' tag is not supported in your current one.</small></p>-->

        <div class="container">
        <h3><a id="tutorial" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tutorial</h3>

        <pre class="mathJax">
          $x \ne y$
        </pre>
        </div>
      </section>
    </div>
  </body>
</html>
